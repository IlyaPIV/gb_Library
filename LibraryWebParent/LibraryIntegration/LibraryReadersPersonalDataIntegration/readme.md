# Интеграционный пакет для взаимодействия с микросервисом персональных данных

## Содержание пакет
pom.xml файл содержит плагин автогенерации клиентского кода для взаимодействия с микросервисом
персональных данных. Спецификация для генерации кода находится в файле openapi_v1.json.
Спецификация сохранена в виде файла для того чтобы не было проблемы с генерацией в случае
отключенного микросервиса. Если микросервис запущен, то её можно брать по адресу
http://__host__:__port__/v3/api-docs (это более правильный подход).

Pom файл также содержит все необходимые зависимости для корректной работы сгенерированного кода.

Для генерации клиентского кода, например, можно воспользоваться командой:
    
    mvn clean compile

## Использование пакета

### Подключение зависимости
Для использования пакета необходимо подключить зависимость

    <dependency>
        <groupId>gb.library</groupId>
        <artifactId>LibraryReadersPersonalDataIntegration</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </dependency>

### Конфигурация
После подключения зависимости необходимо в конфигурационном файле создать два бина.
Первый бин - это ApiClient. Он служит для настройки сетевого взаимодействия с микросервисом.
При его создании необходимо указать хост, порт и т.д. Пример создания бина: 

    @Bean
    public ApiClient apiClient() {
        ApiClient apiClient = new ApiClient();
    
        apiClient.setScheme("http");
        apiClient.setHost("localhost");
        apiClient.setPort(48884);
        apiClient.setConnectTimeout(Duration.of(10, ChronoUnit.SECONDS));
    
        return apiClient;
    }

Второй бин - ReaderApi. Он служит для формирования http запросов к микросервису. При его создании
необходимо в конструкторе указать ApiClient и всё. Пример создания бина:

    @Bean
    public ReaderApi readersApi() {
        return new ReaderApi(apiClient());
    }

### Взаимодействие с микросервисом
Для взаимодействия с микросервисом достаточно инжектировать ReaderApi в какой-нибудь
сервис или контроллер, и вызывать его методы. Но лучшей практикой будет сознание
отдельного специализированного сервиса в котором реализовать всю бизнес-логику
интеграционного взаимодействия, а затем инжектировать его в другой сервис или контроллер.
Пример сервиса:

    @Service
    @RequiredArgsConstructor
    public class ReaderApiService {
    
        private final ReaderApi readerApi;
    
        // Вся бизнес-логика взаимодействия
    }